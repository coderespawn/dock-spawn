var source_steering_h = "#pragma once\n#include \"entity\x2FGameEntity.h\"\n\n\nnamespace syntheticarc {\n\n\tclass SteeringBehaviours {\n\tpublic:\n\t\tSteeringBehaviours();\n\n\t\tvoid Update(float elapsedTime);\n\t\trespawn::math::Vector3 GetSteeringForce(const GameEntity\& host, const GameEntity\& target);\n\t\tvoid SetInitialDirection(const respawn::math::Vector3\& direction);\n\n\t\tbool IsSeekEnabled() const;\n\t\tvoid SetSeekEnabled(bool flag);\n\n\t\tbool IsBounceEnabled() const;\n\t\tvoid SetBounceEnabled(bool flag);\n\n\t\tvoid OnPhysicsContact(const respawn::physics::PhysicsContactPoint\& contactPoint);\n\n\tprivate:\n\t\trespawn::math::Vector3 Seek(const GameEntity\& host, const GameEntity\& target);\n\n\n\tprivate:\n\t\tbool seek;\n\t\tbool bounce;\n\n\t\trespawn::math::Vector3 direction;\t\t\t\x2F\x2F Used for bounce steering behavior\n\t\tfloat timeSinceLastBound;\n\n\t};\n}";
var source_steering_cpp = "\n#include \"GamePrecompiled.h\"\n#include \"SteeringBehaviours.h\"\n#include \x3Cluabind\x2Fluabind.hpp\x3E\n\nusing namespace respawn::renderer;\nusing namespace respawn::math;\nusing namespace respawn::physics;\nusing namespace syntheticarc;\nusing namespace stl;\n\n\nsyntheticarc::SteeringBehaviours::SteeringBehaviours()\n: seek(true), bounce(false), timeSinceLastBound(0)\n{\n}\n\nrespawn::math::Vector3 syntheticarc::SteeringBehaviours::GetSteeringForce(const GameEntity\& host, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  const GameEntity\& target)\n{\n\t\x2F\x2F Get the steering force\n\tVector3 steeringForce = Vector3(0, 0, 0);\n\tif (seek) {\n\t\tsteeringForce = steeringForce + Seek(host, target);\n\t}\n\tif (bounce) {\n\t\tsteeringForce = direction * host.GetMaxSpeed();\n\t}\n\treturn steeringForce;\n}\n\nrespawn::math::Vector3 syntheticarc::SteeringBehaviours::Seek( const GameEntity\& host, const GameEntity\& target )\n{\n\tVector3 desired = target.GetPosition() - host.GetPosition();\n\n\t\x2F\x2F If desired velocity\'s speed component is greater than maxSpeed then truncate it\n\tconst float maxSpeed = target.GetMaxSpeed();\n\tconst float distance = length(desired);\n\tif (distance \x3C 0.000001f) {\n\t\treturn Vector3(0, 0, 0);\n\t}\n\tdesired = desired * (maxSpeed \x2F distance);\n\n\treturn desired - host.GetVelocity();\n}\n\nbool syntheticarc::SteeringBehaviours::IsSeekEnabled() const\n{\n\treturn seek;\n}\n\nvoid syntheticarc::SteeringBehaviours::SetSeekEnabled( bool flag )\n{\n\tthis-\x3Eseek = flag;\n}\n\nvoid syntheticarc::SteeringBehaviours::Update( float elapsedTime )\n{\n\ttimeSinceLastBound += elapsedTime;\n}\n\nvoid syntheticarc::SteeringBehaviours::OnPhysicsContact( const respawn::physics::PhysicsContactPoint\& contactPoint )\n{\n\tif (bounce \&\& timeSinceLastBound \x3E 2.0f \x2F 60) {\n\t\t\x2F\x2F Reflect the current direction based on the contact point\'s normal\n\t\tconst Vector3\& V = direction;\n\t\tconst Vector3\& N = contactPoint.normal;\n\n\t\tdirection = -2 * dot(V, N) * N + V;\n\t\ttimeSinceLastBound = 0;\n\t}\n}\n\nbool syntheticarc::SteeringBehaviours::IsBounceEnabled() const\n{\n\treturn bounce;\n}\n\nvoid syntheticarc::SteeringBehaviours::SetBounceEnabled( bool flag )\n{\n\tthis-\x3Ebounce = flag;\n}\n\nvoid syntheticarc::SteeringBehaviours::SetInitialDirection( const respawn::math::Vector3\& direction )\n{\n\tthis-\x3Edirection = direction;\n}\n";